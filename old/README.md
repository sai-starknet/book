# Sai

A suite of tools and libraries for building cairo based dapps.

## Parts

### Sai - Cairo library and macros

#### A fork in (a) Dojo

<img src="./resources/Sai.png"
     alt="Sai"
     style="width:300px; margin-left: auto; margin-right: auto; display: block;" />

### Elektra - Deployment system

(Or raphael?)

<div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
<img src="./resources/raphael.png"
     alt="Raphael"
     style="width:200px;" />
<img src="./resources/elektra.png"
     alt="Elektra"
     style="width:100px;" />
</div>

### Angle - Off the Chain Indexer

(Or Nick, Nicolas, Simon, Angel or Pegg)

<img src="./resources/off-the-chain.webp"
       alt="Sai"
       style="width:500px; margin-left: auto; margin-right: auto; display: block;" />

---

## Core Cairo Framework

The Sai core Cairo framework is designed for maximum flexibility while remaining highly customizable for specific developer needs. The framework provides modular tools and macros that are loosely coupled, enabling developers to build applications without requiring deep understanding of the entire system architecture.

The framework uses APIs that follow familiar database patterns, making it accessible to developers with traditional backend experience. It includes useful boilerplate code for rapid project setup, including a Dojo-compatible system that enables migration for existing Dojo developers with minimal code changes.

**Key Design Goals:**

- **Modularity**: Easy modification and extension for specific use cases
- **Efficiency**: Optimized performance out of the box
- **Developer Experience**: Intuitive APIs using familiar patterns
- **Extensibility**: Well-defined interfaces that can be easily extended or replaced

Parts to consider for the framework:

- **Storage Layout**: Define how data is stored in the blockchain, including how to hash and access it efficiently.
- **Indexer Interface**: Provide a way to emit events that can be indexed by external systems
- **Contract Interfaces**: Defined ABIs that allow contracts to interact with other contracts with known standardised
  interfaces.
- **Common Tools and Utilities**: Provide a set of common tools and utilities that can be used across different projects, such as permissions management and token utils.

### Dojo

#### Model System

Dojo enables on-chain data storage with efficient indexing through Torii. The Dojo standard defines database tables using models.

Models contain keys and values that define table layouts. The row ID is generated by hashing the serialized keys.

```rust
struct MyModel{
    #[key]
    key_1: u32,
    #[key]
    key_2: felt252,
    value_1: Array<felt252>,
    value_2: u32,
    value_3: Array<MyStruct>,
}
```

The events used to be able to index the model are:

```rust
    pub struct ModelRegistered {
        #[key]
        pub name: ByteArray,
        #[key]
        pub namespace: ByteArray,
        pub class_hash: ClassHash,
        pub address: ContractAddress,
    }
    pub struct StoreSetRecord {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        pub keys: Span<felt252>,
        pub values: Span<felt252>,
    }

    pub struct StoreUpdateRecord {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        pub values: Span<felt252>,
    }

    pub struct StoreUpdateMember {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        #[key]
        pub member_selector: felt252,
        pub values: Span<felt252>,
    }
```

with the id being the hash of the model name and namespace which is computed internally in the world contract. Torii has no requirement for the id to be a hash of the keys or for the tables and namespaces hashes to be a hash of the names.

#### Layout

To communicate the structure of the data, Dojo uses the layout system below.

```rust
pub struct FieldLayout {
    pub selector: felt252,
    pub layout: Layout,
}

pub enum Layout {
    Fixed: Span<u8>,
    Struct: Span<FieldLayout>,
    Tuple: Span<Layout>,
    Array: Span<Layout>,
    FixedArray: Span<(Layout, u32)>,
    ByteArray,
    Enum: Span<FieldLayout>,
}
```

### Storage Layout

We can think of the address of a single storage value as consisting of:

- a base storage salt (for security)
- a table ID (which could be composed of a namespace and a table)
- a row
- a member attribute, where this attribute is the combined hash of the member and its path down to the value.

There are many ways to order the hashing of these elements, and the most efficient approach depends on several factors. Generally, we aim to move as much hashing to **compile time** as possible, since **run-time hashing is expensive**.

#### Dojo Hashing Model

Dojo hashes in this order (ignoring namespace and client-side byte array hashing):

`[STORAGE_BASE, [[table, row], member-attribute]]`

Where:

`member-attribute = [[[member, A1], A2], ..., AN]`

Since Dojo hashes at runtime, the total number of hashes becomes:

$$
R + 2R \cdot \sum_{i=0}^{A} d_A
$$

Where:

- $R$ = Number of rows
- $d_A$ = Depth of attribute $A$

Even if we hash attributes at compile time, the cost remains:

$$
R + 2RA
$$

---

#### Compile-Time Optimization

For fixed models (i.e., no arrays), the column hash for the struct can be computed entirely at compile time.

- Itâ€™s safe to assume that:
  - The table is known at compile time.
  - The row is usually only known at run time.

The hash efficiency also depends on whether the tables are:

- Locally controlled: Accessed via typed functions
- Externally controlled: Accessed via generic write functions

If the table is known at compile time and locally controlled, we can precompute as follows:

```
[[[STORAGE_BASE, table], member-attribute], row]
[[STORAGE_BASE, [table, member-attribute]], row]
[[[STORAGE_BASE, member-attribute], table], row]
```

---

#### External Tables

For fixed external structures, we have two possible hash arrangements with their corresponding costs:

`[[STORAGE_BASE, row], [table, member-attribute]]`

- Cost: $R + RA$

`[[STORAGE_BASE, [table, member-attribute]], row]`

- Cost: $A + RA$

If a simple caller based permissions system is used but if the permissions are based on the table hash, then the cost becomes:

`[[STORAGE_BASE, table], row], member-attribute]`

- Cost: $R + RA$ + 1

`[[[STORAGE_BASE, table], member-attribute], row]`

- Cost: $A + RA$ + 1

`[[STORAGE_BASE, table], [member-attribute, row]]`

- Cost: 2$RA$ + 1

Where:

- $R$ = Number of rows
- $A$ = Number of attributes

---

#### Describing the Storage Layout

For contracts to interact with each other's storage systems, they need a standardized way to communicate storage layouts. This is particularly important when contracts need to read from or write to external storage systems or when building composable applications. Different applications will benefit from different storage layouts, so the system should be flexible enough to allow for different layouts while still being able to communicate them effectively.
One example is a solution that allows for the member's full key to be parsed to the contract allowing compile-time hashing of the member attributes. For a fixed layout it could just consist of a list of values and member-attribute storage locations which would use the `[[STORAGE_BASE, table], [member-attribute, row]]` format. To read a fixed it would make sense to send the full layout and the row ID separately as with enums and we are unsure which bits are needed.

### Compile-Time vs Run-Time Hashing

We want to split hashing into compile-time and run-time components, keeping as much in the compile-time phase as possible.

- Compile-time storage base: When table is known locally
- Run-time storage base: When accessed externally

When parts of the struct are fixed (no arrays), member attributes can also be hashed at compile time.

#### Example: Partial Compile-Time Hashing

```rust
struct FooBar {
    a: Array<Bar>,
    b: u32,
}

struct Bar {
    c: Array<felt252>,
    d: felt252
}
```

We can split the member attribute hash into:

- Static part: \[a, c\]
- Dynamic part (indices): \[N, M\]

The static parts can be pre-hashed with the table.

---

### Indexer Interface

Dojo enables efficient on-chain data storage with indexing through Torii. The Dojo standard defines tables using models.

A proposed structure of the events emitted to the indexer:

```rust
pub enum DatabaseEvents {
    DeclareTable: DeclareTable,
    DeclareTableWithSchema: DeclareTableWithSchema,
    DeclareFields: DeclareFields,
    DeclareField: DeclareField,
    DeclareSchema: DeclareSchema,
    UpdateValue: UpdateValue,
    UpdateRecordFields: UpdateRecordFields,
    UpdateFieldRecords: UpdateFieldRecords,
    UpdateRecordsFields: UpdateRecordsFields,
    UpdateRecordFromSchema: UpdateRecordFromSchema,
    UpdateRecordsFromSchema: UpdateRecordsFromSchema,
}

/// Emitted when a new table is declared with inline field definitions.
///
/// Fields:
/// - `id`: Unique identifier of the table (e.g., hash of the name or a custom ID).
/// - `name`: Human-readable name of the table.
/// - `fields`: List of field layouts (name + layout) associated with this table.

pub struct DeclareTable {
    #[key]
    pub id: felt252,
    pub name: ByteArray,
    pub fields: Span<FieldLayout>,
}

/// Emitted when a table is undeclared.
///
/// Fields:
/// - `id`: Unique identifier of the table (e.g., hash of the name or a custom ID).

pub struct UndeclareTable {
    #[key]
    pub id: felt252,
}

/// Declares a table using a pre-defined schema.
///
/// Fields:
/// - `id`: Unique identifier for the table.
/// - `name`: Human-readable name of the table.
/// - `schema`: The schema declared via `DeclareSchema`.

pub struct DeclareTableWithSchema {
    #[key]
    pub id: felt252,
    pub name: ByteArray,
    pub schema: felt252,
}

/// Declares multiple fields for an existing table.
///
/// Fields:
/// - `table`: Table ID the fields belong to.
/// - `fields`: Array of field definitions (name + layout).

pub struct DeclareTableFields {
    #[key]
    pub table: felt252,
    pub fields: Span<FieldLayout>,
}

/// Declares a single field within a given table.
///
/// Fields:
/// - `table`: Table ID this field belongs to.
/// - `selector`: Field selector (usually feltified name).
/// - `layout`: Layout of the field (e.g., fixed, array, struct).
pub struct DeclareTableField {
    #[key]
    pub table: felt252,
    #[key]
    pub selector: felt252,
    pub layout: Layout,
}


/// Declares a reusable schema layout.
///
/// Fields:
/// - `id`: Deterministic schema ID (e.g., hash of fields).
/// - `fields`: Field layouts (selector + layout), without names.

pub struct DeclareTableSchema {
    #[key]
    pub id: felt252,
    pub fields: Span<FieldLayout>,
}

/// Updates a single field for a single record.
///
/// Fields:
/// - `table`: Table ID.
/// - `record`: Record/entity ID.
/// - `field`: Field selector.
/// - `value`: Value to set.

pub struct UpdateValue {
    #[key]
    pub table: felt252,
    #[key]
    pub record: felt252,
    #[key]
    pub field: felt252,
    pub value: Span<felt252>,
}


/// Updates multiple fields for a single record.
///
/// Fields:
/// - `table`: Table ID.
/// - `record`: Record ID.
/// - `fields`: List of field selectors.
/// - `values`: Concatenated field values (decoded per layout).

pub struct UpdateRecordFields {
    #[key]
    pub table: felt252,
    #[key]
    pub record: felt252,
    pub fields: Span<felt252>,
    pub values: Span<felt252>,
}


/// Updates a single field across multiple records.
///
/// Fields:
/// - `table`: Table ID.
/// - `field`: Field selector.
/// - `records`: List of record IDs.
/// - `values`: Corresponding values for each record.

pub struct UpdateFieldRecords {
    #[key]
    pub table: felt252,
    #[key]
    pub field: felt252,
    pub records: Span<felt252>,
    pub values: Span<felt252>,
}

/// Updates multiple fields across multiple records (row-major order).
///
/// Fields:
/// - `table`: Table ID.
/// - `records`: List of record IDs (rows).
/// - `fields`: List of field selectors (columns).
/// - `data`: Flattened data buffer [record][field] values.

pub struct UpdateRecordsFields {
    #[key]
    pub table: felt252,
    pub records: Span<felt252>,
    pub fields: Span<felt252>,
    pub data: Span<felt252>,
}


/// Updates a record using a predefined schema layout.
///
/// Fields:
/// - `table`: Table ID.
/// - `record`: Record ID.
/// - `schema`: Schema ID (defines field order).
/// - `data`: Field values matching the schema.

pub struct UpdateRecordFromSchema {
    #[key]
    pub table: felt252,
    #[key]
    pub record: felt252,
    #[key]
    pub schema: felt252,
    pub data: Span<felt252>,
}

/// Updates multiple records using a predefined schema layout.
///
/// Fields:
/// - `table`: Table ID.
/// - `schema`: Schema ID.
/// - `records`: List of record IDs.
/// - `data`: Flattened record values following the schema order.

pub struct UpdateRecordsFromSchema {
    #[key]
    pub table: felt252,
    #[key]
    pub schema: felt252,
    pub records: Span<felt252>,
    pub data: Span<felt252>,
}
```

This structure is designed to mimic database operations and be as generic as possible, while still being efficient in gas usage and keeping with databasing convention.

### Contract Interfaces

Interfaces should be defined in a way that allows for easy interaction between contracts in a predictable way. It would be good to use SRC5 to allow introspection of the interfaces.

### Storage Interfaces

Dojo uses a world-based storage system with one contract (the world) containing all the storage for the entire system. This centralized approach provides excellent security and consistency guarantees, making it ideal for many applications. However, for certain use cases where performance is critical or where developers need more control over storage patterns, individual contract storage can offer advantages such as more compile-time optimizations and reduced hashing overhead.

For applications that benefit from a world storage system, the storage interface should be designed to allow any contract to interact with the world storage in a predictable and standardized way.

The read interface is straightforward, requiring only the table ID, row, and storage layout:

```rust
pub impl IContractStoreRead of IStoreRead<Contract> {
    fn store_read_entity(
        self: @Contract, table: felt252, fields: Span<FieldLayout>, id: felt252
    ) -> Span<felt252>;
    fn store_read_entities(
        self: @Contract, table: felt252, fields: Span<FieldLayout>, ids: Span<felt252>
    ) -> Array<Span<felt252>>;
}
```

When it comes to writing, there are more considerations that need to take place, such as permissions and emitting events for indexing. The dojo system uses models to define tables, which provides a solid foundation that we can build upon.

To extend the dojo system, we can generalize the model format in several ways:

- Replace fixed key structures with more flexible approaches
- Categorize values as either read-write (retrievable by the contract) or write-only (accessible only off-chain)
- Allow row IDs to be computed using whatever method makes sense for the specific use case

Interfaces can then be defined to allow for easy interaction with the storage system, including one that allows for direct integration with existing dojo implementations.

## Deployment System

Part of this project is a universal deployment system that allows for easy deployment of smart contracts and their associated data structures. This system is designed to be modular and extensible with addons/plugins that can be used to extend its functionality and be easily modifiable to specific use cases. Deployment can be either config or code driven or a combination of the two, allowing for both quick deployments and more complex setups.

An example config could look like this:

```toml

[account]
rpc_url = "http://localhost:5050/"
account_address = "0x2af9427c5a277474c079a1283c880ee8a6f0f8fbf73ce969c08d88befec1bba"
private_key = "0x1800000000300000180000000000030000000000003006001800006600"

# [caller] # Optional
# account_address = "0x127fd5f1fe78a71f8bcd1fec63e3fe2f0486b6ecd5c86a0466c3a21fa5cfcec"
# private_key = "0xc5b2fcab997346f3ea1c00b002ecf6f382c5f9c9659a3894eb783c5320f912"

[classes.bar]
class_hash = "0x1234567890abcdef1234567890abcdef123456789"

[contracts.pragma]
contract_address = "0x2af9427c5a277474c079a1283c880ee8a6f0f8fbf73ce969c08d88befec1bba"

[declare.foo]
name = "my_contract"
contract_path = "example/src/contract.cairo"
casm_path = "example/target/release/my_contract.json"

[deploy.foo]
class = "foo" # can either be a tag of a declared contract or a
class_hash = "0x1234567890abcdef1234567890abcdef123456789" # can be used instead of tag
salt = "0x0"
unique = false
calldata = ["$account::account_address", "$dojo::models:my_model:class_hash"]


[dojo]
models = "all"
events = []
```

It should also include the use of variables (e.g., `$dojo::models:my_model:class_hash`) and allow for plugins to be included that interact with defined interfaces such as permissions or token management.

Separate plugins can be created for Dojo-style deployment allowing for easy management and upgrading of contracts.

### Referenceable Contracts

#### Static Class Hash

One of the useful things about Dojo is the ability to upgrade contracts without directly knowing the contract address.
One way this could be implemented is through a registry. Another approach is to deploy all contracts from a known class hash and upgrade them immediately as part of a multicall. The tag can then be hashed and used as the salt, so no matter what class the contract gets upgraded to, the address will always be obtainable.

```rust
#[starknet::contract]
mod base_contract {
use starknet::{ClassHash, SyscallResultTrait};

    #[storage]
    struct Storage {}

    #[external(v0)]
    fn upgrade(
        ref self: ContractState, class_hash: ClassHash, selector: felt252, calldata: Span<felt252>,
    ) -> Span<felt252> {
        starknet::syscalls::replace_class_syscall(class_hash).unwrap_syscall();

        starknet::syscalls::call_contract_syscall(
            starknet::get_contract_address(), selector, calldata,
        )
            .unwrap_syscall()
    }
}
```

An issue with this is that the constructor will not be called when the contract is upgraded, so any initialization logic will need to be handled in the upgrade function or through a separate initialization call. This could be made into a macro that creates a function that can only be called by the contract itself.

```rust

#[sai::constructor]
fn constructor(ref self: ContractState, args...) {
    // Initialisation logic here
}
```

that gets converted to:

```rust
#[external(v0)]
fn __constructor__(ref self: ContractState, args...) {
    assert(starknet::get_caller_address() == starknet::get_contract_address(), 'Cannot call constructor');
    // Initialisation logic here
}

```

This way the constructor can be called after the contract is upgraded, but only by the contract itself, which unless someone was looking to break it should mean it's only called on upgrade.

#### DNS

Another way to solve the issue is to use a central DNS system that allows contracts to be referenced by a human-readable name. This would allow for easy upgrades and management of contracts by only knowing the world address of the DNS contract, which could be formulated from a tag like above (similar to how Dojo currently does it). This could look something like this:

```rust
use starknet::ContractAddress;

#[starknet::interface]
trait IContractRegistry<TContractState> {
    fn register(
        ref self: TContractState, namespace_hash: felt252, contract_address: ContractAddress,
    );
    fn lookup(self: @TContractState, namespace_hash: felt252) -> ContractAddress;
    fn grant_owner(ref self: TContractState, owner: ContractAddress);
    fn revoke_owner(ref self: TContractState, owner: ContractAddress);
    fn is_owner(self: @TContractState, owner: ContractAddress) -> bool;
}

#[starknet::contract]
mod contract_registry {
    use starknet::storage::{Map, StorageMapReadAccess, StorageMapWriteAccess};
    use starknet::{ContractAddress, get_caller_address};

    #[storage]
    struct Storage {
        contracts: Map<felt252, ContractAddress>,
        owners: Map<ContractAddress, bool>,
    }

    #[abi(embed_v0)]
    impl IContractRegistryImpl of super::IContractRegistry<ContractState> {
        fn register(
            ref self: ContractState, namespace_hash: felt252, contract_address: ContractAddress,
        ) {
            self.assert_caller_is_owner();
            self.contracts.write(namespace_hash, contract_address);
        }

        fn lookup(self: @ContractState, namespace_hash: felt252) -> ContractAddress {
            self.contracts.read(namespace_hash)
        }

        fn grant_owner(ref self: ContractState, owner: ContractAddress) {
            self.assert_caller_is_owner();
            self.owners.write(owner, true);
        }

        fn revoke_owner(ref self: ContractState, owner: ContractAddress) {
            self.assert_caller_is_owner();
            self.owners.write(owner, false);
        }

        fn is_owner(self: @ContractState, owner: ContractAddress) -> bool {
            self.owners.read(owner)
        }
    }

    #[generate_trait]
    impl PrivateImpl of PrivateTrait {
        fn assert_caller_is_owner(self: @ContractState) {
            assert(self.owners.read(get_caller_address()), 'Caller is not owner');
        }
    }
}
```

This could also be extended to actually deploy contracts.

Each of these systems could have their own plugin that works with the deployment system to allow for easy management of contracts and their associated data structures.
