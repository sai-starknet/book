# Dojo Concepts

Dojo enables on-chain data storage with efficient indexing through Torii. The Dojo standard defines database tables using models.

## Model System

Models contain keys and values that define table layouts. The row ID is generated by hashing the serialized keys.

```rust
struct MyModel{
    #[key]
    key_1: u32,
    #[key]
    key_2: felt252,
    value_1: Array<felt252>,
    value_2: u32,
    value_3: Array<MyStruct>,
}
```

The events used to be able to index the model are:

```rust
    pub struct ModelRegistered {
        #[key]
        pub name: ByteArray,
        #[key]
        pub namespace: ByteArray,
        pub class_hash: ClassHash,
        pub address: ContractAddress,
    }
    pub struct StoreSetRecord {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        pub keys: Span<felt252>,
        pub values: Span<felt252>,
    }

    pub struct StoreUpdateRecord {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        pub values: Span<felt252>,
    }

    pub struct StoreUpdateMember {
        #[key]
        pub selector: felt252,
        #[key]
        pub entity_id: felt252,
        #[key]
        pub member_selector: felt252,
        pub values: Span<felt252>,
    }
```

with the id being the hash of the model name and namespace which is computed internally in the world contract. Torii has no requirement for the id to be a hash of the keys or for the tables and namespaces hashes to be a hash of the names.

## Layout

To communicate the structure of the data, Dojo uses the layout system below.

```rust
pub struct FieldLayout {
    pub selector: felt252,
    pub layout: Layout,
}

pub enum Layout {
    Fixed: Span<u8>,
    Struct: Span<FieldLayout>,
    Tuple: Span<Layout>,
    Array: Span<Layout>,
    FixedArray: Span<(Layout, u32)>,
    ByteArray,
    Enum: Span<FieldLayout>,
}
```

## Hashing Format

Dojo hashes in this order (ignoring namespace and client-side byte array hashing):

```
[STORAGE_BASE, [[table, row], member-attribute]]
```

Where:

```
member-attribute = [[[member, A1], A2], ..., AN]
```

Since Dojo hashes at runtime, the total number of hashes becomes:

$$H = R + 2R \cdot \sum_{i=0}^{A} d_A$$

**Where:**

- _H_ = Number of hash operations
- _R_ = Number of rows
- _d<sub>A</sub>_ = Depth of attribute _A_

Even if we hash attributes at compile time, the cost remains:

$$H = R + 2RA$$
